{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineStore } from 'pinia';\nimport apiClient from '../services/api'; /**\r\n                                         * En el archivo donde se hacen todas éstas peticiones es donde vas a importar el archivo que se está conectando a tu DB.. \r\n                                         * Es decir, en la tienda importamos el codigo que conecta con nuestro backend. \r\n                                         */\n\nexport const useItemStore = defineStore('itemStore', {\n  state: () => ({\n    items: []\n  }),\n  actions: {\n    async fetchItems() {\n      try {\n        const response = await apiClient.get('/api/tarea');\n        this.items = response.data;\n        console.log(this.items);\n      } catch (error) {\n        console.error('Error fetching items:', error);\n      }\n    },\n    async createItem(item) {\n      /*\r\n      NO HACE PETICION A apiClient para hacer peticion al back\r\n      item.id = Date.now().toString();\r\n       this.items.push(item);*/\n\n      try {\n        //Este codigo si PIDE AL BACKEND\n        const response = await apiClient.post('/api/crearTarea', item);\n        this.items.push(response.data); // Agrega el nuevo item a la lista localmente\n      } catch (error) {\n        console.error('Error creating item:', error);\n      }\n    },\n    async editItem(updatedItem) {\n      /*alert(JSON.stringify(updatedItem)) ESTE CODIGO NO HACE PETICION AL BACKEND\r\n      const index = this.items.findIndex(item => item.id === updatedItem.id);\r\n      if (index !== -1) {\r\n      this.items[index] = updatedItem;\r\n      }*/\n\n      try {\n        // ESTE CODIGO SI HACE PETICION AL BACK\n        const response = await apiClient.put(`/editarTarea/${updatedItem.id}`, {\n          texto: updatedItem.titulo,\n          descripcion: updatedItem.descripcion\n        });\n        // Actualiza el item localmente con el item actualizado desde el servidor\n        const index = this.items.findIndex(item => item.id === updatedItem.id);\n        if (index !== -1) {\n          this.items[index] = response.data;\n        }\n      } catch (error) {\n        console.error('Error editing item:', error);\n      }\n    },\n    async deleteItem(id) {\n      /*\r\n      ESTO NO HACE PETICION AL BACK\r\n      this.items = this.items.filter(item => item.id !== id);*/\n\n      try {\n        //Esto si hace peticion al back\n        await apiClient.delete(`/eliminarTarea/${id}`);\n        this.items = this.items.filter(item => item.id !== id);\n      } catch (error) {\n        console.error('Error deleting item:', error);\n      }\n    }\n\n    /**\r\n     * CREAR FUNCION DE COMPLETAR TAREA. \r\n     * \r\n     */\n  }\n});","map":{"version":3,"names":["defineStore","apiClient","useItemStore","state","items","actions","fetchItems","response","get","data","console","log","error","createItem","item","post","push","editItem","updatedItem","put","id","texto","titulo","descripcion","index","findIndex","deleteItem","delete","filter"],"sources":["C:/Users/Yohana/Documents/vue/crud-vue-app/frontend/src/stores/itemStore.js"],"sourcesContent":["import { defineStore } from 'pinia';\r\nimport apiClient from '../services/api'; /**\r\n * En el archivo donde se hacen todas éstas peticiones es donde vas a importar el archivo que se está conectando a tu DB.. \r\n* Es decir, en la tienda importamos el codigo que conecta con nuestro backend. \r\n */\r\n\r\nexport const useItemStore = defineStore('itemStore', {\r\n  state: () => ({\r\n    items: []\r\n  }),\r\n  actions: {\r\n    async fetchItems() {\r\n      try {\r\n        const response = await apiClient.get('/api/tarea');\r\n        this.items = response.data;\r\n        console.log(this.items)\r\n      } catch (error) {\r\n        console.error('Error fetching items:', error);\r\n      }\r\n    },\r\n    async createItem(item) {\r\n     /*\r\n     NO HACE PETICION A apiClient para hacer peticion al back\r\n     item.id = Date.now().toString();\r\n      this.items.push(item);*/\r\n\r\n      try { //Este codigo si PIDE AL BACKEND\r\n        const response = await apiClient.post('/api/crearTarea', item);\r\n        this.items.push(response.data); // Agrega el nuevo item a la lista localmente\r\n      } catch (error) {\r\n        console.error('Error creating item:', error);\r\n      }\r\n    },\r\n    async editItem(updatedItem) {\r\n\r\n        /*alert(JSON.stringify(updatedItem)) ESTE CODIGO NO HACE PETICION AL BACKEND\r\n      const index = this.items.findIndex(item => item.id === updatedItem.id);\r\n      if (index !== -1) {\r\n        this.items[index] = updatedItem;\r\n      }*/\r\n\r\n      try {// ESTE CODIGO SI HACE PETICION AL BACK\r\n        const response = await apiClient.put(`/editarTarea/${updatedItem.id}`, {\r\n          texto: updatedItem.titulo,\r\n          descripcion: updatedItem.descripcion,\r\n        });\r\n        // Actualiza el item localmente con el item actualizado desde el servidor\r\n        const index = this.items.findIndex(item => item.id === updatedItem.id);\r\n        if (index !== -1) {\r\n          this.items[index] = response.data;\r\n        }\r\n      } catch (error) {\r\n        console.error('Error editing item:', error);\r\n      }\r\n    },\r\n    async deleteItem(id) {\r\n      /*\r\n      ESTO NO HACE PETICION AL BACK\r\n      this.items = this.items.filter(item => item.id !== id);*/\r\n\r\n      try { //Esto si hace peticion al back\r\n        await apiClient.delete(`/eliminarTarea/${id}`);\r\n        this.items = this.items.filter(item => item.id !== id);\r\n      } catch (error) {\r\n        console.error('Error deleting item:', error);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * CREAR FUNCION DE COMPLETAR TAREA. \r\n     * \r\n     */\r\n  }\r\n});\r\n"],"mappings":";AAAA,SAASA,WAAW,QAAQ,OAAO;AACnC,OAAOC,SAAS,MAAM,iBAAiB,CAAC,CAAC;AACzC;AACA;AACA;;AAEA,OAAO,MAAMC,YAAY,GAAGF,WAAW,CAAC,WAAW,EAAE;EACnDG,KAAK,EAAEA,CAAA,MAAO;IACZC,KAAK,EAAE;EACT,CAAC,CAAC;EACFC,OAAO,EAAE;IACP,MAAMC,UAAUA,CAAA,EAAG;MACjB,IAAI;QACF,MAAMC,QAAQ,GAAG,MAAMN,SAAS,CAACO,GAAG,CAAC,YAAY,CAAC;QAClD,IAAI,CAACJ,KAAK,GAAGG,QAAQ,CAACE,IAAI;QAC1BC,OAAO,CAACC,GAAG,CAAC,IAAI,CAACP,KAAK,CAAC;MACzB,CAAC,CAAC,OAAOQ,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC/C;IACF,CAAC;IACD,MAAMC,UAAUA,CAACC,IAAI,EAAE;MACtB;AACL;AACA;AACA;;MAEM,IAAI;QAAE;QACJ,MAAMP,QAAQ,GAAG,MAAMN,SAAS,CAACc,IAAI,CAAC,iBAAiB,EAAED,IAAI,CAAC;QAC9D,IAAI,CAACV,KAAK,CAACY,IAAI,CAACT,QAAQ,CAACE,IAAI,CAAC,CAAC,CAAC;MAClC,CAAC,CAAC,OAAOG,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAC9C;IACF,CAAC;IACD,MAAMK,QAAQA,CAACC,WAAW,EAAE;MAExB;AACR;AACA;AACA;AACA;;MAEM,IAAI;QAAC;QACH,MAAMX,QAAQ,GAAG,MAAMN,SAAS,CAACkB,GAAG,CAAC,gBAAgBD,WAAW,CAACE,EAAE,EAAE,EAAE;UACrEC,KAAK,EAAEH,WAAW,CAACI,MAAM;UACzBC,WAAW,EAAEL,WAAW,CAACK;QAC3B,CAAC,CAAC;QACF;QACA,MAAMC,KAAK,GAAG,IAAI,CAACpB,KAAK,CAACqB,SAAS,CAACX,IAAI,IAAIA,IAAI,CAACM,EAAE,KAAKF,WAAW,CAACE,EAAE,CAAC;QACtE,IAAII,KAAK,KAAK,CAAC,CAAC,EAAE;UAChB,IAAI,CAACpB,KAAK,CAACoB,KAAK,CAAC,GAAGjB,QAAQ,CAACE,IAAI;QACnC;MACF,CAAC,CAAC,OAAOG,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,qBAAqB,EAAEA,KAAK,CAAC;MAC7C;IACF,CAAC;IACD,MAAMc,UAAUA,CAACN,EAAE,EAAE;MACnB;AACN;AACA;;MAEM,IAAI;QAAE;QACJ,MAAMnB,SAAS,CAAC0B,MAAM,CAAC,kBAAkBP,EAAE,EAAE,CAAC;QAC9C,IAAI,CAAChB,KAAK,GAAG,IAAI,CAACA,KAAK,CAACwB,MAAM,CAACd,IAAI,IAAIA,IAAI,CAACM,EAAE,KAAKA,EAAE,CAAC;MACxD,CAAC,CAAC,OAAOR,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAC9C;IACF;;IAEA;AACJ;AACA;AACA;EACE;AACF,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}